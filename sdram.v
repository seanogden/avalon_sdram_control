
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module sdram(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,

	//////////// LED //////////
	output		     [8:0]		LEDG,
	output		    [17:0]		LEDR,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [31:0]		DRAM_DQ,
	output		     [3:0]		DRAM_DQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_WE_N
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
reg [23:0] addr_reg;
reg ack_reg;
reg write_reg;
reg [15:0] write_data_reg;
reg read_reg;
reg [15:0] read_data_reg;
reg [17:0] lights;
reg [3:0] state;

wire [23:0] addr;
wire ack;
wire write;
wire [15:0] write_data;
wire read;
wire [15:0] read_data;
wire reset;
wire clk;
wire [1:0] be;

assign be = 2'b11;
assign clk = CLOCK_50;
assign reset = ~KEY[0];
assign addr = addr_reg;
assign write = write_reg;
assign write_data = write_data_reg;
assign read = read_reg;
assign LEDR = lights;

//=======================================================
//  Structural coding
//=======================================================
  sdram_controller sd1
    (
      .acknowledge_from_the_bridge_0 (ack),
      .address_to_the_bridge_0       (addr),
      .byte_enable_to_the_bridge_0   (byte_enable_to_the_bridge_0),
      .clk_0                         (clk),
      .read_data_from_the_bridge_0   (read_data),
      .read_to_the_bridge_0          (read),
      .reset_n                       (reset_n),
      .write_data_to_the_bridge_0    (write_data),
      .write_to_the_bridge_0         (write),
      .zs_addr_from_the_sdram_0      (DRAM_ADDR),
      .zs_ba_from_the_sdram_0        (DRAM_BA),
      .zs_cas_n_from_the_sdram_0     (DRAM_CAS_N),
      .zs_cke_from_the_sdram_0       (DRAM_CKE),
      .zs_cs_n_from_the_sdram_0      (DRAM_CS_N),
      .zs_dq_to_and_from_the_sdram_0 (DRAM_DQ),
      .zs_dqm_from_the_sdram_0       (DRAM_DQM),
      .zs_ras_n_from_the_sdram_0     (DRAM_RAS_N),
      .zs_we_n_from_the_sdram_0      (DRAM_WE_N)
    );
	
	parameter begin_write = 4'd1,
				 wait_ack_write = 4'd2,
				 begin_read = 4'd3,
				 wait_ack_read = 4'd4,
				 finish_read = 4'd5,
				 done = 4'd6;
	
	always@(posedge clk) ack_reg <= ack;
	 
	always@(posedge clk) begin
		if (reset) begin
			addr_reg <= 0;
			write_reg <= 0;
			write_data_reg <= 0;
			read_reg <= 0;
			read_data_reg <= 0;
			state <= begin_write;
			lights <= 0;
		end
		else begin
			case(state)
				begin_write: begin
					addr_reg <= 0;
					write_reg <= 1;
					write_data_reg <= 16'hdead;
					state <= wait_ack_write;
				end
				
				wait_ack_write: begin
					if (ack_reg == 0) state <= wait_ack_write;
					else begin
						write_reg <= 0;
						state <= begin_read;
					end
				end
				
				begin_read: begin
					addr_reg <= 0;
					read_reg <= 1;
					state <= wait_ack_read;
				end
				
				wait_ack_read: begin
					if (ack_reg == 0) state <= wait_ack_read;
					else begin
						read_data_reg <= read_data;
						read_reg <= 0;
						state <= finish_read;
					end
				end
				
				finish_read: begin
					if (read_data_reg == 16'hdead) lights <= 18'b111111111111111111;
					state <= done;
				end
				
				done: state <= done;
			endcase
		end
	end

endmodule
